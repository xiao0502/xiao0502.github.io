<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[css选择器]]></title>
      <url>/2018/03/04/css-select/</url>
      <content type="html"><![CDATA[<blockquote>
<p>关于css选择器，五花八门，别出心裁，总结下自己平时在工作中遇到的有用实际的一些css选择器吧。</p>
</blockquote>
<h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><pre><code>[href] {
    color: red;
} // 带href属性的标签

[href^=&quot;http] {
    color: red;
} // 带href属性链接以http开头的

[href$=&quot;.cn&quot;] {
    color: red;
} // 带href属性链接以.cn结尾的

[type=&quot;password&quot;] {
    color: red;
} // 带type属性为password的

[class~=&quot;xiao&quot;] {
    color: red;
} // 属性值具有多值时，使用如&lt;p class=&quot;xiao jin&quot;&gt;&lt;/p&gt;
</code></pre><h2 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h2><h3 id="分组选择器"><a href="#分组选择器" class="headerlink" title="分组选择器"></a>分组选择器</h3><pre><code>.class1,
.class2,
.class3 {
    color: red;
}
</code></pre><h3 id="后代选择器"><a href="#后代选择器" class="headerlink" title="后代选择器"></a>后代选择器</h3><pre><code>.class1 .class1-1 {
    color: red;
}
</code></pre><h3 id="子选择器"><a href="#子选择器" class="headerlink" title="子选择器"></a>子选择器</h3><pre><code>.class1 &gt; .class2 {
    color: red;
}
</code></pre><h3 id="相邻兄弟选择器"><a href="#相邻兄弟选择器" class="headerlink" title="相邻兄弟选择器"></a>相邻兄弟选择器</h3><pre><code>.class1 + .class2 {
    color: red;
}
</code></pre><h3 id="兄弟选择器"><a href="#兄弟选择器" class="headerlink" title="兄弟选择器"></a>兄弟选择器</h3><pre><code>.class1 + .class2 {
    color: red;
}
</code></pre><h2 id="伪元素选择器"><a href="#伪元素选择器" class="headerlink" title="伪元素选择器"></a>伪元素选择器</h2><pre><code>:first-line {
    color: red;
} // 作用于块级元素的首行

:first-letter {

} // 作用于块级元素的首字母

:before {
    content: &#39;&#39;;
    display: block;
    backgroud: red;
} // 元素之前插入

:before {
    content: &#39;&#39;;
    display: block;
    backgroud: red;
} // 元素之后插入
</code></pre><h2 id="伪类选择器"><a href="#伪类选择器" class="headerlink" title="伪类选择器"></a>伪类选择器</h2><pre><code>:first-child {
    color: red;
}

:last-child {
    color: red;
}     

:only-child {
    color: red
} // 作用的元素父亲只有这个元素唯一一个元素

:only-of-type {
    color: red;
} // 作用的元素父亲只有这个元素唯一一个类型的元素
</code></pre><h2 id="UI选择器（input）"><a href="#UI选择器（input）" class="headerlink" title="UI选择器（input）"></a>UI选择器（input）</h2><pre><code>input:enabled {
    font-size: 20px;
}

input:disable {
    font-size: 20px;
}

input:checked {
    font-size: 20px;
}

input:default {
    font-size: 20px;
}

input:valid {
    font-size: 20px;
}

input:invalid {
    font-size: 20px;
}

input:required {
    font-size: 20px;
}
</code></pre><h2 id="动态伪类"><a href="#动态伪类" class="headerlink" title="动态伪类"></a>动态伪类</h2><pre><code>:link {
    color: red;
}

:visited {
    color: red;
}

:hover {
    color: red;
}

:active {
    color: red;
}

:focus {
    color: red;
}
</code></pre><h2 id="伪类其他"><a href="#伪类其他" class="headerlink" title="伪类其他"></a>伪类其他</h2><pre><code>:not {
    color: red;
} // 反选

:empty {
    color: red;
} // 空内容

:target {
    color: red;   
} // url中有target的
</code></pre><p>PS： 回头补上以上选择器的兼容性！</p>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css选择器 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[浏览器跨域]]></title>
      <url>/2018/03/02/cross-domain/</url>
      <content type="html"><![CDATA[<blockquote>
<p>跨域是一种现象，一种问题。经常被很多面试官拿出来问，在开发中，和后台联调的时候，也是要解决问题中必不可少的步骤。<br>趁着最近有时间，可以拿出来好好说说，加深自己对跨域的理解，温故而知新。</p>
</blockquote>
<h2 id="跨域是什么？为什么会出现跨域？"><a href="#跨域是什么？为什么会出现跨域？" class="headerlink" title="跨域是什么？为什么会出现跨域？"></a>跨域是什么？为什么会出现跨域？</h2><p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/cross-domain.png"><br>一个完整的域名，包括了 <code>协议</code>、<code>域名</code>、<code>端口号</code>，任何一种不同，就是跨域的出现。<br>上图中的协议是<code>https</code>, 域名是<code>localhost</code>也就是<code>127.0.0.1</code>， 端口号是<code>8080</code><br>浏览器为了保护用户数据安全，防止恶意访问篡改做出的保护手段。</p>
<h2 id="跨域出现了会有什么影响？"><a href="#跨域出现了会有什么影响？" class="headerlink" title="跨域出现了会有什么影响？"></a>跨域出现了会有什么影响？</h2><p>可以参考 阮一峰老师一篇文章 《浏览器同源政策及其规避方法》，这篇文章提到了，跨域后出现的限制</p>
<pre><code>Cookie、LocalStorage 和 IndexDB 无法读取。
DOM 无法获得。
AJAX 请求不能发送。
</code></pre><p>具体细节可以参考这篇文章 <a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html</a> </p>
<h2 id="如何解决跨域？"><a href="#如何解决跨域？" class="headerlink" title="如何解决跨域？"></a>如何解决跨域？</h2><pre><code>JSONP
nginx代理转发
vue开发中proxyTable
</code></pre><h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><blockquote>
<p>JSONP解决跨域是以前一种比较旧的解决方案，而且只能支持get请求，目前基本上不太会用到这种方案了。</p>
</blockquote>
<p>JSONP主要是利用了script标签不受浏览器同源策略的影响的特点，动态添加script标签，自执行前后端约定好字段的函数，<br>从而获取数据，script加载的地址例如 <code>http://demo.com/callback=fn</code></p>
<pre><code>var script = document.createElement(&#39;script);
script.setAttribute(&#39;type&#39;,&#39;text/javascript&#39;);
script.src = http://demo.com/callback=fn
document.body.appendChild(script);

function fn(data) {
    console.log(JSON.stringify(data))
}
</code></pre><p>后台对应的会在所返回的json数据外面包裹fn</p>
<pre><code>fn({
    &quot;code&quot;: 0,
    &quot;msg&quot;: &quot;请求成功&quot;
})
</code></pre><h4 id="nginx"><a href="#nginx" class="headerlink" title="nginx"></a>nginx</h4><blockquote>
<p>nginx代理转发是我用得最多的解决跨域的方案了，简单粗暴还可行。</p>
</blockquote>
<p>接口地址</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/api.png"> </p>
<p>nginx修改代理</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/changeApi.png"> </p>
<p>这样所监听的端口发送请求时，nginx会把请求转发到接口地址 8088端口上</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/8080.png"> </p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/request.png"> </p>
<h4 id="vue中的proxyTable"><a href="#vue中的proxyTable" class="headerlink" title="vue中的proxyTable"></a>vue中的proxyTable</h4><blockquote>
<p>用vue开发项目，自带的proxTable原理与ningx转发请求类似，不需要配置nginx，vue框架已经做好了处理。</p>
</blockquote>
<pre><code>  proxyTable: {
        &#39;/api&#39;: {
            target: &#39;http://localhost:8088&#39;,
            changeOrigin: true,
            pathRewrite: {
                &#39;^/api&#39;: &#39;/api&#39;,
            }
        }
    },
</code></pre>]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 浏览器跨域 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react实现简单登录注册]]></title>
      <url>/2018/02/07/reactAccount/</url>
      <content type="html"><![CDATA[<blockquote>
<p>此篇文章就react技术，实现下简单的H5的登陆注册，<br>进行下面操作时，默认已安装node(6.11.3)和npm()。</p>
</blockquote>
<h2 id="全局安装react官方推荐脚手架"><a href="#全局安装react官方推荐脚手架" class="headerlink" title="全局安装react官方推荐脚手架"></a>全局安装react官方推荐脚手架</h2><p><code>npm install create-react-app -g</code></p>
<h2 id="新建一个react项目"><a href="#新建一个react项目" class="headerlink" title="新建一个react项目"></a>新建一个react项目</h2><p><code>create-react-app react-account</code></p>
<h2 id="进入项目并运行"><a href="#进入项目并运行" class="headerlink" title="进入项目并运行"></a>进入项目并运行</h2><p><code>cd react-account &amp;&amp; npm start</code></p>
<p>运行效果如下：</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/react-start.png"></p>
<p>至此，一个简单的 <code>react-demo</code> 就跑起来了。</p>
<h2 id="删除官方脚手架src开发目录的代码，新建demo"><a href="#删除官方脚手架src开发目录的代码，新建demo" class="headerlink" title="删除官方脚手架src开发目录的代码，新建demo"></a>删除官方脚手架src开发目录的代码，新建demo</h2><pre><code>// index.js
import React from &#39;react&#39;
import ReactDOM from &#39;react-dom&#39;

ReactDOM.render(
    &lt;div&gt;demo&lt;/div&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><h2 id="释放webpack配置"><a href="#释放webpack配置" class="headerlink" title="释放webpack配置"></a>释放webpack配置</h2><p><code>npm run eject</code></p>
<h2 id="在src开发目录新建所需要的文件及文件夹"><a href="#在src开发目录新建所需要的文件及文件夹" class="headerlink" title="在src开发目录新建所需要的文件及文件夹"></a>在src开发目录新建所需要的文件及文件夹</h2><p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/react-src-1.png"></p>
<p>目录解释：</p>
<pre><code>components： 存放各种木偶组件
containers： 存放各种智能页面
login： 存放登陆页面
register： 存放注册页面
hrInfo： 存放HR详情页面
workerInfo： 存放求职者详情页面
</code></pre><h2 id="布置路由"><a href="#布置路由" class="headerlink" title="布置路由"></a>布置路由</h2><p><code>npm install react-router-dom -S</code></p>
<pre><code>import {BrowserRouter as Router, Route} from &#39;react-router-dom&#39;

import Login from &#39;./containers/login&#39;
import Register from &#39;./containers/register&#39;

ReactDOM.render(
    &lt;Router&gt;
        &lt;div&gt;
            &lt;Route path=&#39;/&#39; component={Login}&gt;&lt;/Route&gt;
            &lt;Route path=&#39;/login&#39; component={Login}&gt;&lt;/Route&gt;
            &lt;Route path=&#39;/register&#39; component={Register}&gt;&lt;/Route&gt;
        &lt;/div&gt;
    &lt;/Router&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><p>这样就可以实现简单的页面路由布置</p>
<h2 id="利用UI框架antd-mobile快速搭建所需页面"><a href="#利用UI框架antd-mobile快速搭建所需页面" class="headerlink" title="利用UI框架antd-mobile快速搭建所需页面"></a>利用UI框架antd-mobile快速搭建所需页面</h2><p>安装UI框架 <code>npm install antd-mobile -S</code><br>安装UI框架按需加载插件 <code>npm install babel-plugin-import -S</code></p>
<p>login/index.js</p>
<pre><code>import React, {Component} from &#39;react&#39;
import {
    List,
    InputItem,
    WingBlank,
    WhiteSpace,
    Button
} from &#39;antd-mobile&#39;
import Logo from &#39;../../components/logo&#39;
import &#39;./login.css&#39;

class Login extends Component {
    constructor(props) {
        super(props);
        this.state = {
            username: &#39;&#39;,
            password: &#39;&#39;
        }
    }

    render() {
        return (
            &lt;div className=&quot;page-login&quot;&gt;
                &lt;Logo/&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;List&gt;
                    &lt;InputItem
                        onChange={val =&gt; this.handleChange(&#39;username&#39;, val)}
                    &gt;项目账号：&lt;/InputItem&gt;
                    &lt;InputItem
                        onChange={val =&gt; this.handleChange(&#39;password&#39;, val)}
                    &gt;项目密码：&lt;/InputItem&gt;
                &lt;/List&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WingBlank&gt;
                    &lt;Button type=&quot;primary&quot;
                            onClick={this.handleLogin.bind(this)}
                    &gt;登录&lt;/Button&gt;
                    &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                    &lt;Button type=&quot;primary&quot;
                            onClick={this.handleGoRegister.bind(this)}
                    &gt;去注册&lt;/Button&gt;
                &lt;/WingBlank&gt;
            &lt;/div&gt;
        )
    }

    // 去注册
    handleGoRegister() {
        this.props.history.push(&#39;/register&#39;)
    }

    // 登陆
    handleLogin() {

    }

    // 数据双向绑定
    handleChange(key, val) {
        this.setState({
            [key]: val
        })
    }
}

export default Login
</code></pre><p>register/index.js  </p>
<pre><code>import React, {Component} from &#39;react&#39;
import {
    List,
    InputItem,
    WingBlank,
    WhiteSpace,
    Button,
    Radio
} from &#39;antd-mobile&#39;
import Logo from &#39;../../components/logo&#39;
import &#39;./register.css&#39;

class Register extends Component {
    constructor(props) {
        super(props);
        this.state = {
            type: &#39;worker&#39;,
            username: &#39;&#39;,
            password: &#39;&#39;,
            passwordConfirm: &#39;&#39;,
        }
    }

    render() {
        const RadioItem = Radio.RadioItem;
        return (
            &lt;div className=&quot;page-register&quot;&gt;
                &lt;Logo/&gt;
                &lt;List&gt;
                    &lt;InputItem
                        onChange={val =&gt; this.handleChange(&#39;username&#39;, val)}
                    &gt;项目账号：&lt;/InputItem&gt;
                    &lt;InputItem
                        onChange={val =&gt; this.handleChange(&#39;password&#39;, val)}
                    &gt;项目密码：&lt;/InputItem&gt;
                    &lt;InputItem
                        onChange={val =&gt; this.handleChange(&#39;passwordConfirm&#39;, val)}
                    &gt;确认密码：&lt;/InputItem&gt;
                &lt;/List&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;List&gt;
                    &lt;RadioItem
                        checked={this.state.type === &#39;worker&#39;}
                        onClick={() =&gt; {
                            this.setState({
                                type: &#39;worker&#39;
                            })
                        }}
                    &gt;求职者&lt;/RadioItem&gt;
                    &lt;RadioItem
                        checked={this.state.type === &#39;hr&#39;}
                        onClick={() =&gt; {
                            this.setState({
                                type: &#39;hr&#39;
                            })
                        }}
                    &gt;HR&lt;/RadioItem&gt;
                &lt;/List&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                &lt;WingBlank&gt;
                    &lt;Button type=&quot;primary&quot;&gt;注册&lt;/Button&gt;
                    &lt;WhiteSpace&gt;&lt;/WhiteSpace&gt;
                    &lt;Button type=&quot;primary&quot;
                            onClick={this.handleGoLogin.bind(this)}
                    &gt;已有账号，去登录&lt;/Button&gt;
                &lt;/WingBlank&gt;
            &lt;/div&gt;
        )
    }

    // 去登陆
    handleGoLogin() {
        this.props.history.push(&#39;/login&#39;)
    }

    // 数据双向绑定
    handleChange(key, val) {
        this.setState({
            [key]: val
        })
    }
}

export default Register
</code></pre><p>这里注意到，实现react的双向数据绑定，用的函数提取</p>
<pre><code>handleChange(key, val) {
    this.setState({
        [key]: val
    })
}
</code></pre><p>尤其要注意到这里的 <code>[key]</code> ，不能直接用 <code>key</code> ,不然会被当做字符串</p>
<h2 id="利用express启动服务，MongoDB作为数据库"><a href="#利用express启动服务，MongoDB作为数据库" class="headerlink" title="利用express启动服务，MongoDB作为数据库"></a>利用express启动服务，MongoDB作为数据库</h2><blockquote>
<p>我们再这里用MongoDB作为用户注册时候的数据库，用express启动服务提供接口，用axios作为请求工具</p>
</blockquote>
<p>安装MongoDB： <code>sudo brew install mongodb</code> （这里是MAC安装方式，其他平台自行google）<br>安装mondoose： <code>npm install mongoose -D</code> （MongoDB数据库插件）<br>安装axios： <code>npm install axios -S</code><br>安装express：<code>npm install express -S</code></p>
<p>项目根目录新建server文件夹，里面新建index.js作为服务的入口</p>
<pre><code>// server/index.js
const express = require(&#39;express&#39;);

const app = express();

app.get(&#39;/&#39;, (req, res) =&gt; {
    res.send(&#39;hi, express&#39;);
})

app.listen(8000, () =&gt; {
    console.log(`server is running at localhost:8000`);
})
</code></pre><p>安装nodemon： <code>npm install nodemon -g</code> （node的实时监听）</p>
<p>启动服务： <code>nodemon server/index.js</code></p>
<p>访问 <code>localhost:8000</code> ,就可以在页面上看到 <code>hi, express</code></p>
<p>接着对接口做处理，server下新建user.js作为路由中间件</p>
<pre><code>const express = require(&#39;express&#39;)

// 生成express中间件
const Router = express.Router();

Router.get(&#39;/loginStatus&#39;, (req, res) =&gt; {
    res.json({
        code: 1,
        msg: &#39;用户未登录&#39;
    })
})

module.exports = Router
</code></pre><p>这样我们就写死了一个登陆状态为未登录的接口服务。</p>
<h2 id="编写判断登陆组件"><a href="#编写判断登陆组件" class="headerlink" title="编写判断登陆组件"></a>编写判断登陆组件</h2><blockquote>
<p>项目实现登陆注册，首先得判断用户是否登陆。结合上面的接口，这里会涉及到跨域的问题。<br>react项目中解决跨域问题也是非常简单的。</p>
</blockquote>
<pre><code>// package.json
&quot;proxy&quot;: &quot;http://localhost:8000&quot;
</code></pre><p>checkLogin/index.js</p>
<pre><code>import {Component} from &#39;react&#39;
import axios from &#39;axios&#39;
import {withRouter} from &#39;react-router-dom&#39;  // 由于checkLogin 不是路由，要想用跳转的话得引入withRouter

@withRouter
class CheckLogin extends Component {
    render() {
        return null
    }

    componentDidMount() {
        // 登陆注册页面无需判断登陆状态
        let noCheckRouter = [&#39;/login&#39;, &#39;/register&#39;]
        if (noCheckRouter.indexOf(this.props.history.location.pathname) &gt; -1) {
            return
        }

        axios.get(&#39;/user/loginStatus&#39;)
            .then(res =&gt; {
                console.log(res.data);
                if (res.data.code === 1) {
                    this.props.history.push(&#39;/login&#39;)
                }
            })
    }
}

export default CheckLogin
</code></pre><p>checkLogin/index.js 中，当用户未登录时，强制跳转到登陆页面，这里涉及到路由跳转，<br>而checkLogin/index.js不是路由，得用 <code>react-router-dom</code> 中的 <code>withRouter</code><br>这里可以利用 <code>babel-plugin-transform-decorators-legacy</code>支持 <code>withRouter</code><br>的装饰器写法，这个插件也为后面的redux装饰器写法提供方便。</p>
<p>安装装饰器插件： <code>npm install babel-plugin-transform-decorators-legacy -D</code><br>使用：</p>
<pre><code>&quot;babel&quot;: {
    &quot;presets&quot;: [
      &quot;react-app&quot;
    ],
    &quot;plugins&quot;: [
      //和之前添加的UI框架按需加载插件一样用法
      &quot;transform-decorators-legacy&quot;, 
      [
        &quot;import&quot;,
        {
          &quot;libraryName&quot;: &quot;antd-mobile&quot;,
          &quot;style&quot;: &quot;css&quot;
        }
      ]
    ]
  },
</code></pre><p>然后在入口文件index.js中使用</p>
<pre><code>ReactDOM.render(
    &lt;Router&gt;
        &lt;div className=&quot;react-account&quot;&gt;
            &lt;CheckLogin/&gt;
            &lt;Route path=&#39;/login&#39; component={Login}&gt;&lt;/Route&gt;
            &lt;Route path=&#39;/register&#39; component={Register}&gt;&lt;/Route&gt;
            &lt;Route path=&#39;/hrInfo&#39; component={HrInfo}&gt;&lt;/Route&gt;
            &lt;Route path=&#39;/workerInfo&#39; component={WorkerInfo}&gt;&lt;/Route&gt;
        &lt;/div&gt;
    &lt;/Router&gt;,
    document.getElementById(&#39;root&#39;)
)
</code></pre><p>因为之前接口是写死的未登录，判断登陆组件先写到这里，MongoDB数据库搭建完模型后继续补充。</p>
<h2 id="MongoDB数据库"><a href="#MongoDB数据库" class="headerlink" title="MongoDB数据库"></a>MongoDB数据库</h2><pre><code>const mongoose = require(&#39;mongoose&#39;)

// mongoose 连接这个数据库并生成&quot;react-account&quot;这个集合
mongoose.connect(&#39;mongodb://127.0.0.1:27017/react-account&#39;)

// 连接成功后的打印
mongoose.connection.on(&#39;connected&#39;,() =&gt; {
    console.log(&#39;mongo connect success&#39;);
})

// 创建数据模型

const models = {
    user: {
        &#39;username&#39;: {type: String, require: true},
        &#39;password&#39;: {type: String, require: true},
        &#39;type&#39;: {type: String, require: true},
    }
}

// 遍历生成数据模型
for(let m in models) {
    mongoose.model(m, new mongoose.Schema(models[m]))
}

// 导出供其他地方获取
module.exports = {
    getModel: function (m) {
        return mongoose.model(m)
    }
}
</code></pre><p>运行 <code>mongo</code> 即可</p>
<p>这里需要安装两个插件 <code>body-parser</code> 和 <code>cookie-parser</code></p>
<p><code>npm install body-parser -S</code> （后台数据接口用户传进来的参数解析插件）<br><code>npm install cookie-parser -S</code> （通过cookie存储用户登录状态）</p>
<p>使用：</p>
<pre><code>// server/index.js
const bodyParser = require(&#39;body-parser&#39;)
const cookieParser = require(&#39;cookie-parser&#39;)

app.use(bodyParser.json())
app.use(cookieParser())
</code></pre><h2 id="实现用户注册"><a href="#实现用户注册" class="headerlink" title="实现用户注册"></a>实现用户注册</h2><blockquote>
<p>注册接口这里要用到 <code>react</code> 的另一个核心 <code>redux</code></p>
</blockquote>
<p>未带待续~~</p>
]]></content>
      
        <categories>
            
            <category> react </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[初窥浏览器渲染过程和原理]]></title>
      <url>/2018/02/06/bowserPaint/</url>
      <content type="html"><![CDATA[<blockquote>
<p>了解浏览器的渲染过程和原理，有利于我们前端人员实现一些项目的具体优化方案，例如首屏渲染、按需加载等等；</p>
</blockquote>
<p>上一张图，先看为敬！</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/renderTree.jpg"></p>
<p>首先了解一个词，<code>关键渲染路径</code>，即与当前用户操作有关的内容，<br>最直接的体现就是<code>首屏渲染</code>。了解浏览器的渲染过程，<br>大部分就是为了优化关键渲染路径，避免长时间的白屏，提升用户体验；</p>
<p>上个知识点《网页从开始请求到最终显示的完整过程》中说到过浏览器请求加载渲染一个页面的基本过程，精简下来，就是五个步骤：</p>
<pre><code>1. DNS查询
2. TCP连接
3. HTTP请求
4. 服务器响应
5. 浏览器渲染
</code></pre><p>这个知识点主要说第五个步骤，<code>浏览器渲染</code>，细分下来，也可以是补个步骤：</p>
<pre><code>1. 处理HTML构建DOM树
2. 处理CSS构建CSSOM树
3. 将DOM和CSSOM合并成一个render（渲染树）
4. 将render布局，计算每个节点的几何信息（Layout）
5. 将节点绘制在屏幕上（Paint）
</code></pre><p>要知道，上述的五个步骤不是一次性顺序进行，一旦DOM和CSSOM被修改，<br>就会重新计算并渲染（Repaint），<br>而在实际开发中，CSS和JS都是会经常修改DOM和CSSOM的。</p>
<pre><code>CSS和JS都会阻塞DOM加载，一旦发生阻塞，解析器会停止构建DOM。
CSS阻塞时，浏览器会延迟JS脚本执行和DOM构建，知道CSSOM构建完毕。
JS阻塞时，DOM暂停构建，直至脚本执行完毕。
</code></pre><p>所以在实际开发中，有<code>两个原则</code>：</p>
<pre><code>1. CSS优先： CSS优先于JS资源
2. JS尽量减少对DOM构建的影响
</code></pre><p>这里对比下Repaint和Reflow,前者是元素的改变不影响布局，后者是布局被影响，渲染成本高</p>
<p>有可能<code>触发Reflow的行为</code>：</p>
<pre><code>1. 增删改DOM节点
2. 增删class属性值
3. 元素尺寸大小
4. 文本内容大小
5. 浏览器窗口改变大小或者拖动
6. 动画效果
7. 伪类
</code></pre><p>在上述行为中，浏览器不是每次Reflow或者Repaint就立即执行，而是积累到一定时候，就会Reflow或者Repaint，<br>当然有些行为，比如改变浏览器窗口大小是立即执行Reflow或者Repaint的。</p>
<p>说了上述些后，可以谈谈优化浏览器渲染过程的<code>具体实现</code>了。</p>
<ol>
<li>指定文档编码 <meta charset="utf-8"></li>
<li>CSS放在 <code>&lt;head&gt;</code> 里面， js放在 <code>&lt;/body&gt;</code> 结束标签之前</li>
<li>不要逐条修改CSS样式，提前定义好class样式，<code>对css进行操作</code></li>
<li>CSS的引入利用 <code>媒体查询</code> ，接触对渲染的阻塞   </li>
<li>JS的引入适当添加defer或者async,虽然都是 <code>异步加载</code> ，但是前者有序，后者无序</li>
</ol>
]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 浏览器渲染 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[网页从开始请求到最终显示的完整过程]]></title>
      <url>/2018/02/05/urlResolve/</url>
      <content type="html"><![CDATA[<blockquote>
<p>从浏览器地址栏输入网址，到呈现我们想要的内容，可能只需要0.1秒钟甚至更短的时间，但是其中经历了什么呢？</p>
</blockquote>
<ol>
<li>在浏览器中 <code>输入网址</code> ；</li>
<li>通过向 <code>本地域名服务器</code> 、 <code>根域名服务器</code> 、 <code>顶级域名服务器</code> 等一系列DNS服务器发送请求，<br>获取网址对应的 <code>服务器IP地址</code>；</li>
<li>与服务器建立 <code>TCP</code>（传输控制协议）连接；</li>
<li>客户端（浏览器）向服务器（即IP地址）发送 <code>HTTP请求</code> ；</li>
<li>服务器响应请求后返回 <code>指定url的数据</code> ，如果有重定向的话，则跳转到重定向的url地址；</li>
<li>浏览器下载返回的数据后 <code>解析并渲染排版</code> ，显示基础页面；</li>
<li>分析页面中的超链接并显示，重复以上过程，直至 <code>完成全部数据显示</code> ；</li>
</ol>
<blockquote>
<p>提到TCP协议，不得不说到TCP协议中的经典的 <code>三次握手</code> 和 <code>四次挥手</code> ；</p>
</blockquote>
<pre><code>三次握手
一次：客户端向服务器发送连接请求报文；
二次：服务器接受连接报文回复ACK报文，并为这次连接分配相关资源；
三次：客户端接收到服务器的ACK报文，也向服务器发送报文，并分配资源；
</code></pre><p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/tcp-1.png"></p>
<p>用通俗的话理解上面这段话的意思就是：</p>
<p><code>张三</code> 和 <code>李四</code> 在街上碰面，张三问李四： “你吃了吗？”<br>李四要是听不懂张三的话不回答，或者回答的不是吃了没之类的问题，表示连接失败；</p>
<p>李四回答张三： “吃了，你吃了吗？”<br>同样的，张三要是听不懂李四的话不回答，或者回答的不是吃了没之类的问题，连接失败；</p>
<p>张三回答李四： “我也吃了，回头见哈~”<br>此时才算是张三和李四才可以畅聊，此时他们经过了 <code>三次握手询问</code> 。</p>
<pre><code>四次挥手
一次：客户端（服务器也可以主动发起中断连接）向服务器端发送中断连接请求（FIN报文）；
二次：服务器发送一个ACK报文给客户端并告诉客户端，服务器收到中断连接请求，请客户端等待；
三次：服务器发送FIN报文给客户端，并中断连接；
四次：客户端想服务端发送ACK报文，等待2MSL后没有回复，证明服务端已中断，客户端再中断连接；
</code></pre><p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/tcp-2.png"></p>
<p><code>ACK报文</code> : 确认标注； <code>FIN报文</code> ：结束标注；两者都是属于TCP传输控制协议中的几种状态；</p>
<p>这里就可以简单的回答下关于TCP协议中的两个常见问题：</p>
<ol>
<li><p>为什么连接的时候是三次握手，关闭的时候却是四次握手？<br>握手时候，服务器收到客户端连接请求报文后，可以应答（ACK）后并同步（SYN），<br>但是中断连接则不行，数据传输是异步，所以服务器收到FIN报文后，不会立刻关闭，只能等数据传输完毕；</p>
</li>
<li><p>为什么TIME_WAIT状态需要经过2MSL(最大报文段生存时间)才能返回到CLOSE状态？<br>客户端最后想服务器发送ACK报文后进入TIME_WAIT状态，经过2MSL，可以是本次连接内的所有报文段消失，下个新的链接的请求报文可以重新开始；</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> html </category>
            
        </categories>
        
        
        <tags>
            
            <tag> URL到页面渲染 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[找个地儿，写点东西]]></title>
      <url>/2018/02/04/firstArticle/</url>
      <content type="html"><![CDATA[<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;一直想找个地儿好好写点东西，之前买过域名和服务器，准备好好弄个个站搞点事情，无奈设计排版编辑等一系列老大难问题摆在面前，一直没时间去好好落到实地。年关将至，这一年感触多,收获也有点，抽点时间出来，在<code>github个站</code>、<code>hexo静态站点生成器</code>、<code>next主题</code>等一系列的智能化工具的帮助之下，个站算是简单的成了，有个地儿好好记录记录，吐槽吐槽，抒发抒发。</p>
]]></content>
      
        <categories>
            
            <category> 开篇 </category>
            
        </categories>
        
        
    </entry>
    
    <entry>
      <title><![CDATA[十分钟建站利器—github+hexo+next]]></title>
      <url>/2018/02/02/buildStation/</url>
      <content type="html"><![CDATA[<blockquote>
<p> 关于 <code>hexo</code> 建站主题 <code>next</code> 的个性化技巧，随便百度谷歌没有上百也有大几十篇，<br>再继续介绍next的个性化技巧，就显得有点无趣了。这里主要给大家分享一个已经配置好的<br>了next主题文件和如何使用的说明，毕竟大多数人利用github建立个站都是为了<code>写点东西</code>。</p>
</blockquote>
<h2 id="新建github个站"><a href="#新建github个站" class="headerlink" title="新建github个站"></a>新建github个站</h2><p>注册github账号后，新建一个包含与账户名相同的仓库，如下：</p>
<p><img class="demoImg" src="http://p3idd1hk8.bkt.clouddn.com/store.png"></p>
<p>建好仓库后，可以用仓库名字去访问自己的 <code>github个站</code> ，可以随便丢个index.html进去，<br>就能看到自己的主页了。</p>
<h2 id="hexo模板建站步骤"><a href="#hexo模板建站步骤" class="headerlink" title="hexo模板建站步骤"></a>hexo模板建站步骤</h2><ol>
<li>全局安装hexo-cli脚手架<br><code>npm install hexo-cli -g</code></li>
<li>初始化建站模板<br><code>hexo init yourBlogName</code></li>
<li><p>进入项目并安装依赖<br><code>cd yourBlogName &amp;&amp; npm install</code></p>
<p> 新建完成后，会生成如下目录：</p>
<pre><code> ├── _config.yml // 项目配置文件
 ├── package.json
 ├── scaffolds
 ├── source // 开发目录
 |   └── _posts
 └── themes // 主题目录
</code></pre></li>
</ol>
<p>hexo主要命令行介绍</p>
<p>清除缓存：<code>hexo clean</code><br>代码编译：<code>hexo g</code><br>代码开发：<code>hexo s</code><br>发布上线：<code>hexo d</code></p>
<h2 id="下载next主题并修改配置文件"><a href="#下载next主题并修改配置文件" class="headerlink" title="下载next主题并修改配置文件"></a>下载next主题并修改配置文件</h2><p>我根据自己的喜欢简单，对hexo的next主题做了些基础的修改，下载地址：<a href="http://p3idd1hk8.bkt.clouddn.com/next.zip" target="_blank" rel="noopener">next主题下载</a><br>hexo建站后默认的主题是 <code>landscape</code>，将下载后的文件解压后，放在themes文件夹，<br>修改配置文件 <code>_config.yml</code> 如下几点：</p>
<pre><code>1. 修改首页默认地址
    url: https://xiao0502.github.io/ 
2. git代码上传配置
    deploy:
      type: git
      repo: https://github.com/xiao0502/xiao0502.github.io.git 
      branch: master
3. 主题换成next
    theme: next 
</code></pre><h2 id="上线三部曲"><a href="#上线三部曲" class="headerlink" title="上线三部曲"></a>上线三部曲</h2><p>上线三部曲， <code>hexo clean</code>  <code>hexo g</code>  <code>hexo d</code> , 搞定！</p>
]]></content>
      
        <categories>
            
            <category> next个性化 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> next </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
